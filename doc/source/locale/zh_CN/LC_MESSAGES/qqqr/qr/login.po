# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, aioqzone
# This file is distributed under the same license as the aioqzone package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: aioqzone \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-19 09:58+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../source/qqqr/qr/login.rst:2
msgid "QrLogin and QrSession"
msgstr ""

#: of qqqr.qr.QrLogin.new:1
msgid "Create a new :class:`LoginSession`."
msgstr ""

#: of qqqr.qr.QrLogin.new qqqr.qr.QrLogin.poll qqqr.qr.QrLogin.show
msgid "返回类型"
msgstr ""

#: of qqqr.qr.QrLogin.new:4
msgid ":sphinx_autodoc_typehints_type:`\\:py\\:class\\:\\`\\~qqqr.qr.QrSession\\``"
msgstr ""

#: of qqqr.qr.QrLogin.show:1
msgid "``ptqrshow`` api."
msgstr ""

#: of qqqr.qr.QrLogin.login qqqr.qr.QrLogin.show
msgid "参数"
msgstr ""

#: of qqqr.qr.QrLogin.show:4
msgid "push QR to mobile client."
msgstr ""

#: of qqqr.qr.QrLogin.show:6
msgid ":sphinx_autodoc_typehints_type:`\\:py\\:class\\:\\`\\~qqqr.qr.QR\\``"
msgstr ""

#: of qqqr.qr.QrLogin.poll:1
msgid "Poll QR status."
msgstr ""

#: of qqqr.qr.QrLogin.login qqqr.qr.QrLogin.poll
msgid "抛出"
msgstr ""

#: of qqqr.qr.QrLogin.poll:3
msgid "if response status code != 200"
msgstr ""

#: of qqqr.qr.QrLogin.poll:5
msgid ":sphinx_autodoc_typehints_type:`\\:py\\:class\\:\\`\\~qqqr.qr.type.PollResp\\``"
msgstr ""

#: of qqqr.qr.QrLogin.poll
msgid "返回"
msgstr ""

#: of qqqr.qr.QrLogin.poll:6
msgid "a poll response object"
msgstr ""

#: of qqqr.qr.QrLogin.login:1
msgid ""
"Loop until cookie is returned or max `refresh_times` exceeds. - This method will emit "
":obj:`.qr_fetched` event if a new qrcode is fetched. - If qr is not scanned after "
"`refresh_times`, it will raise :exc:`UserTimeout`. - If :obj:`.refresh` is set, it will refresh "
"qrcode at once without increasing expire counter. - If :obj:`.cancel` is set, it will raise "
":exc:`UserBreak` before next polling."
msgstr ""

#: of qqqr.qr.QrLogin.login:9
msgid "max qr expire times."
msgstr ""

#: of qqqr.qr.QrLogin.login:11
msgid "interval between two status polling, in seconds, default as 3."
msgstr ""

#: of qqqr.qr.QrLogin.login:13
msgid "if qr is not scanned after `refresh_times` expires."
msgstr ""

#: of qqqr.qr.QrLogin.login:14
msgid "if :obj:`.cancel` is set."
msgstr ""

#: ../../../docstring of qqqr.qr.QR.png:1
msgid "If None, the QR is pushed to user's client."
msgstr ""

#~ msgid "Return type"
#~ msgstr ""

#~ msgid "Raises"
#~ msgstr ""

#~ msgid "Returns"
#~ msgstr ""

#~ msgid "Block until cookie is received."
#~ msgstr ""

#~ msgid ":meth:`._loop`"
#~ msgstr ""

#~ msgid ":py:class:`~qqqr.qr.QrSession`"
#~ msgstr ""

#~ msgid ":py:class:`~qqqr.qr.type.PollResp`"
#~ msgstr ""

#~ msgid ""
#~ "Loop until cookie is returned or max "
#~ "`refresh_times` exceeds. - This method will emit "
#~ ":meth:`QrEvent.QrFetched` event if a new qrcode is "
#~ "fetched. - If qr is not scanned after "
#~ "`refresh_times`, it will raise :exc:`asyncio.TimeoutError`. -"
#~ " If :obj:`QrEvent.refresh_flag` is set, it will "
#~ "refresh qrcode at once without increasing expire "
#~ "counter. - If :obj:`QrEvent.cancel_flag` is set, it "
#~ "will raise :exc:`UserBreak` before next polling."
#~ msgstr ""

#~ msgid "if :obj:`QrEvent.cancel_flag` is set."
#~ msgstr ""
